% Advent of Code 2025. Day 01: Secret Entrance. 
% gs -DNOSAFER aoc01.ps

/read-input
{                                       % fn
    [                                   % fn [
    exch                                % [ fn 
    (r) file                            % [ F
    {   
        dup                             % [ .. F F
        20 string                       % [ ... F F buf
        readline                        % [ ... F (s) 
        {   
            exch                        % [ ... (s) F
        }   
        {   
            exch                        % [ ... (s) F 
            closefile                   % [ ... (s) 
            ]                           % [ ... (s) ] 
            exit    
        } ifelse    
    } loop                              % Rs
} def 

/left {                                     % z c p r 
    (\nleft\n) print
    1 index 0 eq                            % z c p r p=0?
    {
        (starting a 0!\n) print
        3 -1 roll
        1 sub  
        3 1 roll 
    } if 
    sub                                     % z c n
    % pstack
    {
        dup 0 lt                            % z c n n<0?
        {                                   % z c n 
            (less than 0\n) print
            100 add                         % z c n'
            dup 0 ne
            {
                (!= 0 => add 1 passby\n) print
                exch 1 add exch             % z c++ n' 
            } if 
        } 
        {
            dup 0 eq                        % z c n n=0?
            {                               % z c n
                (landed on zero!\n) print
                3 -1 roll                   % c n z  
                1 add                       % c n z++
                3 1 roll                    % z c n 
            }                               % z c n 
            if 
            pstack
            exit
        }
        ifelse 
    } loop 
} def 

/right {                                    % z c p r 
    (\nright\n) print
    % 1 index 0 eq                            % z c p r p=0?
    % {
    %     (starting a 0!\n) print
    %     3 -1 roll
    %     1 sub  
    %     3 1 roll 
    % } if 
    add                                     % z c n
    % pstack
    {
        dup 99 gt                           % z c n n>99?
        {                                   % z c n 
            (greater than 99\n) print
            100 sub                         % z c n'
            dup 0 ne
            {
                (!= 0 => add 1 passby\n) print
                exch 1 add exch             % z c++ n' 
            } if 
        } 
        {
            dup 0 eq                        % z c n n=0?
            {                               % z c n
                (landed on zero!\n) print
                3 -1 roll                   % c n z  
                1 add                       % c n z++
                3 1 roll                    % z c n 
            }                               % z c n 
            if 
            pstack
            exit
        }
        ifelse 
    } loop 
} def 

/compile {                                  % s
    dup length 0 eq                         % s L?
    { pop {} }
    {
        dup 0 get                           % s D
        (L) 0 get eq                        % s B
        { /left } { /right } ifelse cvx     % s P
        exch                                % P s
        dup length 1 sub                    % P s L-1
        1 exch                              % P s 1 L-1
        getinterval cvi                     % P n
        exch                                % n P
        [ 3 1 roll ] cvx                    % { n P }
    }
    ifelse
} def 

% 0
% 0
% 50
% (L68) compile 

% exec 

/run {
    % Read
    read-input
    { compile exec } forall

} def 

0 0 50 
(input.txt) run 
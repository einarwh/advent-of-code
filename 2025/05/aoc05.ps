% Advent of Code 2025. Day 05: Cafeteria. 
% gs -DNOSAFER aoc05.ps

/read-input
{                                       % fn
    [                                   % fn [
    exch                                % [ fn 
    (r) file                            % [ F
    {   
        dup                             % [ .. F F
        80 string                       % [ ... F F buf
        readline                        % [ ... F (s) 
        {   
            exch                        % [ ... (s) F
        }   
        {   
            exch                        % [ ... (s) F 
            closefile                   % [ ... (s) 
            ]                           % [ ... (s) ] 
            exit    
        } ifelse    
    } loop                              % Rs
} def 

/split-at {                             % i A 
    2 copy                              % i A i A 
    0 exch                              % i 0 A i A 
    getinterval                         % A'=A[0,i-1] i A
    3 1 roll                            % i A A' 
    1 index length                      % L i A A'
    1 index                             % i L i A A'
    sub                                 % c i A A'
    getinterval                         % A''=A[i,L-1] A'
} def 

% A => [ more? ix A ]
/iter-state {                           % A  
    dup length                          % A L  
    0                                   % A L 0 
    exch                                % A 0 L 
    1 index                             % A 0 L 0  
    gt                                  % A 0 L>0? 
    3 array                             % A 0 L>0? A' 
    astore                              % A' % [ L>0? 0 A ]
} def 

/next-state {                           % I 
    dup                                 % I I 
    aload pop                           % ? i A I
    {                                   % i A I (true)
        1 add                           % i+1 A I 
        1 index length                  % L i+1 A I
        1 index                         % i+1 L i+1 A I 
        gt                              % L>i+1? i+1 A I
        3 array astore                  % I' I 
        exch pop                        % I'
    }
    {                                   % i A I (false)
        pop pop                         % I 
    } ifelse
} def

/compare-ranges {                       % [a b] [c d]
    1 index 0 get                       % [a b] [c d] a 
    1 index 0 get                       % [a b] [c d] a c 
    sub                                 % [a b] [c d] a-c 
    dup                                 % [a b] [c d] a-c a-c
    0 eq                                % [a b] [c d] a-c a=c?
    {                                   % [a b] [c d] a-c %%% a=c
        pop                             % [a b] [c d]
        1 index 1 get                   % [a b] [c d] b
        1 index 1 get                   % [a b] [c d] b d
        sub                             % [a b] [c d] b-d
    } if
    3 1 roll                            % b-d [a b] [c d]
    pop pop                             % b-d
} def 

/range-lt {                             % [a b] [c d]
    compare-ranges                      % cmp 
    0 lt                                % [a b] < [c d]
} def 

% I1 I2 => a I1' I2
/choose-next                            % I1 I2 
{
    dup                                 % I1 I1 I2
    aload pop                           % more1? i1 A1 I1 I2
    {                                   % i1 A1 I1 I2 (i1 in range)
        get                             % a1 I1 I2 
        2 index                         % I2 a1 I1 I2 
        aload pop                       % more2? i2 A2 a1 I1 I2 
        {                               % i2 A2 a1 I1 I2 (i2 in range)
            get                         % a2 a1 I1 I2 
            2 copy                      % a2 a1 a2 a1 I1 I2 
            range-lt                    % a1<a2? a2 a1 I1 I2 
            {                           % a2 a1 (a1 < a2) I1 I2 
                pop                     % a1 I1 I2 
                exch                    % I1 a1 I2 
                next-state              % I1' a1 I2 
                exch                    % a1 I1' I2 
            }
            {                           % a2 a1 (a2 < a1)
                exch pop                % a2 I1 I2
                3 -1 roll               % I2 a2 I1 
                next-state              % I2' a2 I1 
                3 1 roll                % a2 I1 I2'
            } ifelse                    % a I1 I2
        }
        {                               % i2 A2 a1 I1 I2 (i2 out of range)
            pop pop                     % a1 I1 I2 
            exch                        % I1 a1 I2 
            next-state                  % I1' a1 I2 
            exch                        % a1 I1' I2 
        } ifelse                        % a I1 I2
    } 
    {                                   % i1 A1 I1 I2 (i1 out of range, i2 must be in range)
        pop pop                         % I1 I2 
        1 index                         % I2 I1 I2 
        aload pop                       % more2? i2 A2 I1 I2 
        {                               % i2 A2 I1 I2 (i2 in range)
            get                         % a2 I1 I2 
            3 -1 roll                   % I2 a2 I1 
            next-state                  % I2' a2 I1 
            3 1 roll                    % a2 I1 I2'
        }
        {                               % I2 A2 I1 I2 (i2 out of range)
            (out of range\n) print
            pop pop "err"
        } ifelse                        % a I1 I2 
    } ifelse                            % a I1 I2 
} def

/merge {                                % A2 A1  
    2 copy                              % A2 A1 A2 A1 
    length                              % A2 A1 A2 L1 
    exch                                % A2 A1 L1 A2 
    length                              % A2 A1 L1 L2 
    add                                 % A2 A1 L 
    array                               % A2 A1 A 
    3 1 roll                            % A A2 A1 
    iter-state                          % A A2 I1 
    exch                                % A I1 A 
    iter-state                          % A I1 I2 
    2 index                             % A I1 I2 A  
    length                              % A I1 I2 L 
    1 sub                               % A I1 I2 L-1 
    0 exch                              % A I1 I2 j=0 L-1 
    1 exch                              % A I1 I2 j k=1 L-1 
    {                                   % A I1 I2 i 
        3 1 roll                        % A i I1 I2  
        choose-next                     % A i I1 I2 a  
        4 index                         % A i I1 I2 a A  
        5 -1 roll                       % A I1 I2 a A i  
        3 -1 roll                       % A I1 I2 A i a 
        put                             % A I1 I2 
    } for                               % A I1 I2  
    pop pop                             % A 
} def

% A => A' 
/merge-sort {                           % C A 
    dup length                          % C A L 
    1                                   % C A L 1 
    gt                                  % C A L>1? 
    {                                   % C A %%% (L>1)
        dup length                      % C A L 
        2 idiv                          % C A L/2 
        split-at                        % C A2 A1
        merge-sort                      % C A2 A1'
        exch                            % C A1' A2
        merge-sort                      % C A1' A2'
        merge                           % C A' 
    } if                                % C A'
} def 

/compare-ranges {                       % [a b] [c d]
    1 index 0 get                       % [a b] [c d] a 
    1 index 0 get                       % [a b] [c d] a c 
    sub                                 % [a b] [c d] a-c 
    dup                                 % [a b] [c d] a-c a-c
    0 eq                                % [a b] [c d] a-c a=c?
    {                                   % [a b] [c d] a-c %%% a=c
        pop                             % [a b] [c d]
        1 index 1 get                   % [a b] [c d] b
        1 index 1 get                   % [a b] [c d] b d
        sub                             % [a b] [c d] b-d
    } if
    3 1 roll                            % b-d [a b] [c d]
    pop pop                             % b-d
} def 

% A = [ s1 s2 ... sn ] => [ G1 G2 ... Gn ]
/group-lines {                          % A
    [ exch                              % A | 
    [ exch                              % A | | 
    {                                   % s ... | ... |
        dup length                      % L[s] s ... | ... | 
        0 eq                            % empty? s ... | ... |
        {                               % () ... | ... |
            pop                         % ... | ... |
            ]                           % G ... | 
            [                           % | G ... |
        }
        {                               % s ... | ... | 
        } ifelse                        % ... | 
    } forall 
    ]                                   % G ... | 
    dup length                          % L[G] G ... | 
    0 eq                                % empty? G ... | 
    {                                   % () ... | 
        pop
    } if
    ]                                   % [ G1 G2 ... Gn ]
} def 

/map-array {                            % A {op} %%% {op} is operation to be called for each element in A
    [ 3 1 roll                          % [ A {op}
    exch                                % [ {op} A
    {                                   % [ {op} e
        1 index                         % [ {op} e {op}
        exec                            % [ {op} r %%% r is result of executing {op} on e
        exch                            % [ r {op}
    } forall                            % [ ... {op}
    pop                                 % [ ...
    ]                                   % [ r1 r2 ... ]
} def

/filter-array {                         % A {p} %%% {p} is predicate to be called for each element in A
    [ 3 1 roll                          % [ A {p}
    exch                                % [ {p} A
    {                                   % [ {p} e
        2 copy                          % [ {p} e {p} e
        exch                            % [ {p} e e {p}
        exec                            % [ {p} e include?
        {                               % [ {p} e %%% yes, keep e
            exch                        % [ e {p}
        }
        {                               % [ {p} e %%% no, reject e
            pop                         % [ {p}
        } ifelse                        % [ e? {p}
    } forall                            % [ ... {p}
    pop                                 % [ ...
    ]                                   % [ e... ]
} def 

/exists-array {                         % A {p} %%% {p} is predicate to be called for each element in A
    false 3 1 roll                      % F A {p} %%% Assume F
    exch                                % F {p} A
    {                                   % F {p} e
        1 index                         % F {p} e {p}
        exec                            % F {p} satisfied?
        {                               % F {p} yes! %%% terminate with true
            exch pop                    % {p} %%% dropped default false
            true exch                   % T {p}
            exit                        % T {p} - out of loop
        } if                            % 
    } forall                            % B {p}
    pop                                 % B
} def 

/split-string {                         % (s=string) (z=sep) 
    [                                   % s z [ 
    3 1 roll                            % [ s z  
    {                                   % [ s z
        search                          % [ s'=rest (h=head z)? found?
        {                               % [ s' z h (yes, found)
            3 1 roll                    % [ h s' z  
        }       
        {                               % [ s  (not found)
            exit                        % [ s
        } ifelse        
    } loop      
    ]                                   % [ .. ]
} def 

/in-range {                             % (r:range=[s e]) (i=num) 
    exch                                % i r 
    aload pop                           % i s e 
    2 index ge                          % i s i<=e
    3 1 roll                            % i<=e i s 
    ge                                  % i<=e i>=s
    and                                 % s<=i && i<=e
} def 

/in-any-range {                         % (rs:ranges=[[s e]...]) (i=num) 
    [ exch                              % rs [ i 
    /in-range cvx                       % rs [ i in-range
    ] cvx                               % rs { i in-range } 
    exists-array 
} def 

/create-range-filter {
    [ exch /exch cvx /in-any-range cvx ] cvx 
} def 

/tail {                                 % A
    dup length                          % A L 
    1 sub                               % A L-1 
    1 exch                              % A 1 L-1
    getinterval                         % A[1:]
} def 

/count-fresh {                          % rs 
    0 exch                              % n rs 
    0 exch                              % n i rs
    {                                   % n i rs 
        dup length                      % n i rs L 
        0 eq                            % n i rs L=0?
        {
            pop                         % n i 
            exit                        % n i 
        } if
        dup 0 get                       % n i rs [x y]
        dup 0 get                       % n i rs [x y] x 
        3 index exch                    % n i rs [x y] i x 
        lt                              % n i rs [x y] i<x?
        {                               % n i rs [x y] %%% i<x
            0 get                       % n i rs x
            3 -1 roll pop               % n rs x
            exch                        % n x rs
        }
        {                               % n i rs [x y] %%% i>=x
            dup 1 get                   % n i rs [x y] y
            3 index exch                % n i rs [x y] i y
            gt                          % n i rs [x y] i>y?
            {                           % n i rs [x y] %%% i>y
                pop                     % n i rs
                tail                    % n i t
            }
            {                           % n i rs [x y] %%% i<=y
                1 get                   % n i rs y 
                exch                    % n i y rs 
                4 1 roll                % rs n i y 
                3 1 roll                % rs y n i 
                sub                     % rs y n-i
                1 add                   % rs y n-i+1
                1 index add             % rs y n-i+1+y
                exch 1 add              % rs n-i+1+y y+1
                3 -1 roll               % n-i+1+y y+1 rs
            } ifelse
        } ifelse 
    } loop                              % n i 
    pop                                 % n
} def 

/run {
    (input.txt) read-input  
    group-lines
    aload pop 
    { cvi } map-array 
    exch 
    { (-) split-string { cvi } map-array } map-array
    exch 1 index 
    create-range-filter
    filter-array
    length 
    exch 
    merge-sort
    count-fresh
} def 

run 
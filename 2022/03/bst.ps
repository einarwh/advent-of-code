% Binary search tree. 
% Node: [ [ v L R ] | [null] ]

/bst-value-index 0 def 

/bst-left-child-index 1 def 

/bst-right-child-index 2 def 

/bst-wrap {
    1 array astore 
} def 

/bst-unwrap {
    0 get 
} def 

/bst-create-empty {                         % 
    null                                    % _
    bst-wrap                                % T
} def   

/bst-create-node {                          % v 
    null null                               % v _ _ 
    3 array                                 % v _ _ A 
    astore                                  % V
    bst-wrap
} def   

/bst-get-value {                            % T
    (bst-get-value\n) print
    dup bst-is-nil                          % T T=nil?
    {
        pop 
        (tried to get value of nil\n) print
        stop
    }
    {                                       % T (T is not nil)
        bst-unwrap                          % U 
        bst-value-index get                 % v
    } ifelse 
} def   

/bst-get-left-child {                       % T
    (bst-get-left-child\n) print
    dup bst-is-nil                          % T T=nil?
    {
        pop
        (tried to get left child of nil\n) print
        stop
    }
    {                                       % T (T is not nil)
        bst-unwrap                          % U 
        bst-left-child-index get            % L
    } ifelse 
} def

/bst-get-right-child {                      % T
    (bst-get-right-child\n) print
    dup bst-is-nil                          % T T=nil?
    {
        pop
        (tried to get right child of nil\n) print
        stop
    }
    {                                       % T (T is not nil)
        bst-unwrap                          % U 
        bst-right-child-index get           % R
    } ifelse 
} def

/bst-put-value {                            % T v
    (bst-put-value\n) print
    exch                                    % v T
    dup bst-is-nil                          % v T T=nil?   
    {                                       % v T (T is nil)
        pop pop                             % 
        (tried to update value of nil node\n) print
        stop
    }
    {                                       % v T (T is not null)
        bst-unwrap                          % v U 
        exch                                % U v 
        bst-value-index                     % U v i
        exch                                % U v i
        put                                 %
    } ifelse 
} def   

/bst-put-left-child {                       % T L
    (bst-put-left-child\n) print
    exch                                    % L T
    dup bst-is-nil                          % L T T=nil?   
    {                                       % L T (T is null)
        pop pop                             % 
        (tried to update left child of nil node\n) print
        stop
    }
    {                                       % L T (T is not null)
        bst-unwrap                          % L U 
        exch                                % U L 
        bst-left-child-index                % U L i
        exch                                % U i L
        put                                 %
    } ifelse 
} def   

/bst-put-right-child {                      % T R
    (bst-put-right-child\n) print
    exch                                    % R T
    dup bst-is-nil                          % R T T=nil?   
    {                                       % R T (T is null)
        pop pop                             % 
        (tried to update left child of nil node\n) print
        stop
    }
    {                                       % R T (T is not null)
        bst-unwrap                          % R U 
        exch                                % U R 
        bst-right-child-index               % U R i
        exch                                % U i R
        put                                 %
    } ifelse 
} def 

/bst-is-nil {                               % T
    bst-unwrap                              % U
    null eq                                 % U=null?
} def 

/bst-insert {                               % T x 
    (bst-insert\n) print
    exch                                    % x T
    dup bst-is-nil                          % x T T=nil? 
    {                                       % x T (T is nil)
        (bst-insert: T is nil\n) print
        exch                                % T x 
        bst-create-node                     % T X(x)
        bst-unwrap                          % T U(x)
        pstack
        0 exch put                          %
    }       
    {                                       % x T (T is not nil)
        (bst-insert: T is not nil\n) print
        exch                                % T x
        1 index bst-get-value               % T x v 
        2 copy eq                           % T x v x=v?
        {                                   % T x v (v=x, already present!)
            pop pop pop                     % 
        }       
        {                                   % T x v (v!=x, insert x)
            2 copy                          % T x v x v 
            gt                              % T x v (x>v?)
            {                               % T x v (x>v: x -> right)
                2 index                     % T x v T
                bst-get-right-child         % T x v R
                null eq                     % T x v R=null?
                {                           % T x v (R is null, insert directly at R)
                    pop                     % T x 
                    bst-create-node         % T N
                    bst-put-right-child     %
                }
                {                           % T x v (R is not null, recurse)
                    pop                     % T x 
                    exch                    % x T 
                    bst-get-right-child     % x R 
                    exch                    % R x 
                    bst-insert              % 
                } ifelse                    % 
            }
            {                               % T x v (x<v: x -> left)
                2 index                     % T x v T
                bst-get-left-child          % T x v L
                null eq                     % T x v L=null?
                {                           % T x v (L is null, insert directly at L)
                    pop                     % T x 
                    bst-create-node         % T N
                    bst-put-left-child      %
                }
                {                           % T x v (L is not null, recurse)
                    pop                     % T x 
                    exch                    % x T 
                    bst-get-left-child      % x L
                    exch                    % L x 
                    bst-insert              % 
                } ifelse                    % 
            } ifelse                        % 
        } ifelse                            %
    } ifelse                                %
} def

/bst-contains {                             % T x 
    exch dup                                % x T T 
    null eq                                 % x T ? 
    {                                       % x T (T is null)
        pop pop                             %
        false                               % f
    }
    {                                       % x T 
        exch                                % T x
        1 index bst-get-value               % T x v 
        2 copy eq                           % T x v x=v?
        {                                   % T x v (v=x, found it!)
            pop pop pop                     % 
            true                            % t
        }
        {                                   % T x v (v!=x, continue search for x)
            2 copy                          % T x v x v 
            gt                              % T x v (x>v?)
            {                               % T x v (x>v: search right subtree)
                pop                         % T x 
                exch                        % x T 
                bst-get-right-child         % x R 
                exch                        % R x 
                bst-contains                % b
            }
            {                               % T x v (x<v: search left subtree)
                pop                         % T x 
                exch                        % x T 
                bst-get-left-child          % x R 
                exch                        % R x 
                bst-contains                % b
            } ifelse 
        } ifelse 
    } ifelse 
} def 

/bst-min-node {                             % T 
    dup null ne                             % T
    {                                       % T (T is not null)
        dup bst-get-left-child              % T L
        dup                                 % T L L 
        null eq                             % T L L=null?
        {                                   % T L (L is null, return T)
            pop                             % T
        }
        {                                   % T L (L is not null, recur)
            exch pop                        % L
            bst-min-node                    % M
        } ifelse
    } if 
} def 

/bst-min-value {                            % T
    bst-min-node                            % M
    bst-get-value                           % m
} def 

/bst-max-node {                             % T 
    dup null ne                             % T
    {                                       % T (T is not null)
        dup bst-get-right-child             % T R
        dup                                 % T R R 
        null eq                             % T R R=null?
        {                                   % T R (R is null, return T)
            pop                             % T
        }
        {                                   % T R (R is not null, recur)
            exch pop                        % R
            bst-max-node                    % M
        } ifelse
    } if 
} def 

/bst-max-value {                            % T
    bst-max-node                            % M
    bst-get-value                           % m
} def 

/bst-overwrite {                            % T N 
    2 copy                                  % T N T N 
    bst-get-value bst-put-value             % T N 
    2 copy                                  % T N T N 
    bst-get-left-child bst-put-left-child   % T N 
    bst-get-right-child bst-put-right-child %
} def 

/bst-remove-return-root {                   % T x
    (bst-remove-return-root\n) print
    (remove value ) print 
    dup == 
    (\n) print
    pstack
    (\n) print

    exch dup                                % x T T 
    null eq                                 % x T ? 
    {                                       % x T (T is null, it wasn't here)
        (done, it wasn't here\n) print
    
        pop pop                             %
        null                                % _
    }
    {                                       % x T 
        (It's not null\n) print
        pstack
        (\n) print

        exch                                % T x
        1 index bst-get-value               % T x v 
        2 copy eq                           % T x v x=v?
        {                                   % T x v (v=x, found it! now we have work to do)
            (Found the node with the value to remove!\n) print
            pstack
            (\n) print

            pop pop                         % T
            dup                             % T T
            bst-get-right-child             % T R 
            null eq                         % T R=null?
            {                               % T (R is null, return L as root)
                (R is null, return L\n) print
                pstack
                (\n) print

                dup bst-get-left-child      % T L (regardless if L is null or not)

                (Is this L?\n) print
                pstack
                (\n) print
            }
            {                               % T (R is not null)
                (R is not null, check L\n) print
                pstack
                (\n) print

                dup                         % T T 
                bst-get-left-child          % T L
                null eq                     % T L=null?
                {                           % T (L is null, return R as root)
                    (L is null, return R\n) print
                    pstack
                    (\n) print

                    bst-get-right-child     % R
                    (Return value is R on top \n) print
                    pstack
                    (\n) print
                }
                {                           % T (Neither is null)
                    (Neither is null, it's complicated.\n) print
                    pstack
                    (\n) print

                    dup                     % T T 
                    bst-get-right-child     % T R 
                    bst-min-value           % T m
                    (Got min larger value.\n) print
                    pstack
                    (\n) print

                    2 copy                  % T m T m 
                    (Make recursive remove call.\n) print
                    pstack
                    (\n) print

                    bst-remove-return-root  % T m T
                    (Returned from recursive remove.\n) print
                    pstack
                    (\n) print

                    exch                    % T T m
                    bst-put-value           % T 
                } ifelse 
            } ifelse                        % T N

            % Should have replacement node on top of stack here.
            % But what if replacement node is null?
            % Can't overwrite non-null node with null.
            % Must have fixed, non-null root.
            1 index exch                    % T T N 
            bst-overwrite                   % T<-N
        }
        {                                   % T x v (v!=x, continue search for x)
            (It's the wrong value: ) print
            dup == 
            (Continue search\n) print
            pstack
            (\n) print

            2 copy                          % T x v x v 
            gt                              % T x v (x>v?)
            {                               % T x v (x>v: remove from right child)
                (The value to remove is greater. Remove from right child\n) print
                pstack
                (\n) print

                pop                         % T x 
                1 index                     % T x T
                bst-get-right-child         % T x R 
                exch                        % T R x 

                (Call recursive remove to the right...\n) print
                pstack
                (\n) print

                bst-remove-return-root      % T R
                1 index exch                % T T R

                (After recursive remove to the right...\n) print
                pstack
                (\n) print

                bst-put-right-child         % T 

                (After put right child...\n) print
                pstack
                (\n) print

            }
            {                               % T x v (x<v: remove from left child)
                (The value to remove is smaller. Remove from left child\n) print
                pstack
                (\n) print

                pop                         % T x 
                1 index                     % T x T
                bst-get-left-child          % T x L 
                exch                        % T L x 

                (Call recursive remove to the left...\n) print
                pstack
                (\n) print

                bst-remove-return-root      % T L
                1 index exch                % T T L

                bst-put-left-child          % T 
            } ifelse 
        } ifelse 
    } ifelse 
} def 

/bst-remove {                               % T x
    bst-remove-return-root pop              % 
} def 

/bst-from-array {                           % A 
    dup length                              % A L 
    0 eq                                    % A L=0?
    {                                       % A (A empty)
        pop null                            % _
    }
    {                                       % A (A not empty)
        dup 0 get                           % A e 
        bst-create-node                     % A N
        exch                                % N A
        {                                   % N e
            1 index                         % N e N 
            exch                            % N N e 
            bst-insert                      % N
        } forall
    } ifelse 
} def 

[5 3 6 7 1 2 4] bst-from-array
dup 5 bst-remove

%[6 [4 [1 null null] null] null]
%dup 6 bst-remove

%[[3 [[1 null [[2 null null]]]] [[4 null [[8 [[6 null null]] null]]]]]]
%dup 2 bst-insert